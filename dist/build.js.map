{"version":3,"file":"build.js","sources":["../node_modules/object-assign/index.js","../src/transform.js","../node_modules/v-deep-clone/index.js","../src/store.js","../src/mixin.js","../src/v-node.vue","../src/v-leaf.vue","../src/v-branch.vue","../src/index.vue","../src/install.js","../src/index.js"],"sourcesContent":["/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","import objectAssign from 'object-assign';\n\n/**\n * standardlize a normal tree object\n * \n * @param data   data to be transformed\n * @param conf   contains keys to extract data from `data`\n * @param level  identifier inferring depth\n */\nexport default transform;\n\nfunction transform(data = {}, config, level, path) {\n  let { node, branch, leaf, check, open } = config;\n  let name = data[node] || '/';\n  let branches = data[branch] || [];\n  let leafs   = data[leaf] || [];\n  let canOpen  = branches.length > 0 || leafs.length > 0;\n\n  path = path || `/${name}`;\n  \n  branches = branches.map((branch, i) => {\n    return transform(branch, config, `${level}.${i}`, `${path}/${branch.name}`);\n  });\n  \n  leafs = leafs.map((leaf, i) => {\n    return {\n      name: leaf,\n      type: 'leaf',\n      check,\n      level: `${level}.${i}`,\n      path: `${path}/${leaf}`\n    };\n  });\n\n  let status = canOpen ? 'filled' : 'empty';\n\n  return {\n    name,\n    type: 'branch',\n    level,\n    path,\n    node: { name, open, canOpen, check, level, path, type: 'node', status },\n    branches,\n    leafs,\n  };\n};\n\n// function raw(tree, conf) {\n//   conf = objectAssign({}, conf, defaultConf);\n//   let { node, branch, leaf } = conf;\n//   let ret = {};\n//   ret[node] = tree.name;\n//   ret[branch] = tree.branches.map(b => raw(b, conf));\n//   ret[leaf] = tree.leafs.map(l => l.name);\n//   return ret;\n// }\n\n// transform.raw = raw;\n","module.exports = function clone (obj) {\n  var temp = {};\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n  if (obj instanceof Array) {\n    temp = [];\n  }\n  Object.keys(obj).forEach(function (value) {\n    if (typeof obj[value] === 'object') {\n      temp[value] = clone(obj[value]);\n    } else {\n      temp[value] = obj[value];\n    }\n  });\n  return temp;\n};","import objectAssign from 'object-assign';\nimport deepClone from 'v-deep-clone';\nimport transform from '../src/transform';\n\nconst arrPush = [].push;\nconst noop = _ => _;\nconst defaultConf = {\n  node: 'name',\n  branch: 'dirs',\n  leaf: 'files',\n  open: false,\n  check: -1\n};\n\nexport default class Store {\n  constructor(data, conf) {\n    let path = data.path || data.name;\n    let name = path.split('/').filter(s => !!s).slice(-1)[0] || data.name;\n    data.name = name;\n    this.conf = objectAssign({}, conf, defaultConf);\n    this.dataStore = transform(data, this.conf, '0', path);\n  }\n\n  /**\n   * set data store\n   * @private\n   */\n  replace(newTree) {\n    this.dataStore = newTree;\n  }\n\n  /**\n   * get parent branch by levelId.\n   * result for a leaf is the branch it is on,\n   * for a branch,  result is it's parent branch.\n   * \n   * @private\n   * @param levelId\n   */\n  findParentBranch(levelId = '') {\n    let length = levelId.length;\n    let branch = this.dataStore;\n\n    if (length <= 1) {\n      return null;\n    }\n    \n    let lvs    = levelId.split('.').slice(1, -1);\n    let index  = 0;\n\n    while (branch && (index = lvs.shift())) {\n      branch = branch.branches[index];\n    }\n\n    return branch;\n  }\n\n  /**\n   * get current branch\n   * \n   * @private\n   * @param levelId \n   */\n  findCurrentBranch(levelId = '') {\n    let lvs    = levelId.split('.').slice(1);\n    let index  = 0;\n    let branch = this.dataStore;\n\n    while (branch && (index = lvs.shift())) {\n      branch = branch.branches[index];\n    }\n\n    return branch;\n  }\n\n  /**\n   * check ascendents of certain level rescursively\n   * to see if they should get checked\n   * this is a passive ation\n   * \n   * @private\n   * @param branch    the descendent branch\n   * @param check     the descendent's check status\n   */\n  checkBranchAscendents(branch, check) {\n    if (!branch) return;\n\n    let { branches, leafs, node, level } = branch;\n    let nextStatus = 0;\n\n    switch (check) {\n      case 1:\n        // at least nextStatus will be zero,\n        // so let's see if all children checked\n        let branchesAllChecked = !branches.length || !branches.some(b => b.node.check < 1);\n        let leafsAllChecked = !leafs.length || !leafs.some(f => f.check < 1);\n        nextStatus = branchesAllChecked && leafsAllChecked ? 1 : 0;\n        break;\n\n      case 0:\n        // no doubt\n        nextStatus = 0;\n        break;\n\n      case -1:\n        // if all children are -1\n        // we'll get -1\n        // else we'll get 0\n        let branchesAllUnchecked = !branches.length || !branches.some(b => b.node.check > -1);\n        let leafsAllUnChecked = !leafs.length || !leafs.some(f => f.check > -1);\n        nextStatus = branchesAllUnchecked && leafsAllUnChecked ? -1 : 0;\n        break;\n    }\n\n    node.check = nextStatus;\n    this.checkBranchAscendents(this.findParentBranch(level), nextStatus);\n  }\n\n  /**\n   * check branch children and decendents.\n   * if node is checked, all children are checked too and vice versa.\n   *\n   * @private\n   * @param branch   current descendent branch\n   * @param check    the ascendent's check status\n   */\n  checkBranchDescendents(branch, check) {\n    branch.node.check = check;\n    if (!check) return;\n    branch.leafs.forEach(l => l.check = check);\n    branch.branches.forEach(b => {\n      b.node.check = check;\n      this.checkBranchDescendents(b, check);\n    });\n  }\n\n  /************************************************************************\n   * * * * * * * * * * * * Public Method Below * * * * * * * * * * * * * * \n   ************************************************************************/\n  /**\n   * if one node is checked/unchecked,\n   * we have to check/uncheck all ites descendents,\n   * and find if its ascendents should be checked.\n   * \n   * @param level  level of the node checked/unchecked\n   */\n  checkNode(node) {\n    // node.check: -1(unchecked) 0(imtermedite) 1(checked)\n    // 0 -> 1 (and state 0 is passive)\n    // 1 <=> -1\n    let branch = this.findCurrentBranch(node.level);\n    let checkState = branch.node.check;\n    let nextState = checkState < 1 ? 1 : -1;\n    this.checkBranchDescendents(branch, nextState);\n    this.checkBranchAscendents(this.findParentBranch(branch.level), nextState);\n  }\n  \n  /**\n   * if a leaf is checked,\n   * we have to check all its ascendents\n   * to see if any should get checked to.\n   * \n   * @param leaf\n   */\n  checkLeaf(leaf) {\n    let leafBranch = this.findParentBranch(leaf.level);\n    let nextState = -1 * leaf.check;\n    leaf.check = nextState;\n    this.checkBranchAscendents(leafBranch, nextState);\n  }\n\n   /**\n    * merge a branch to current tree\n    * @param branch\n    */\n  merge(\n    data = {},\n    node = {\n      level: '0',\n      path: ''\n    }\n  ) {\n    let { level, path, check } = node;\n    let lvs = level.split('.').slice(1);\n    let branch = transform(data, this.conf, level, path);\n\n    branch.node.open = true;\n    branch.node.check = check;\n    branch.node.status = 'done';\n\n    if (lvs.length === 0) {\n      this.replace(branch);\n    } else {\n      let clone = deepClone(this.dataStore);\n      let top   = clone;\n      let pos   = lvs.pop();\n      let index = 0;\n\n      while (index = lvs.shift()) {\n        top = top.branches[index];\n      }\n      top.branches.splice(pos, 1, branch);\n      top.node.canOpen = true;\n\n      this.replace(clone);\n    }\n\n\n    this.checkBranchDescendents(branch, check);\n  }\n\n  /**\n   * deal with actions\n   */\n  commit(action, elem, callback = noop) {\n    let isNode = elem.type === 'node';\n    \n    switch (action) {\n      case 'change':\n        this[isNode ? 'checkNode' : 'checkLeaf'](elem);\n        callback(this.getPathResult());\n        break;\n\n      case 'fold':\n        if (isNode) {\n          elem.open = !elem.open;\n          elem.canOpen || elem.status === 'done' || callback();\n        }\n        break;\n    }\n  }\n\n  /**\n   * get result as path\n   */\n  getPathResult(branch) {\n    branch = branch || this.dataStore;\n\n    let result = [];\n    let { node, branches, leafs, path } = branch;\n\n    if (node.check > 0) {\n      result.push(branch.path);\n    } else {\n      leafs.forEach(({ check, path }) => {\n        if (check > 0) {\n          result.push(path);\n        }\n      });\n\n      branches.forEach(branch => {\n        arrPush.apply(result, this.getPathResult(branch))\n      });\n    }\n\n    return result;\n  }\n\n  raw() {\n    return transform.raw(this.dataStore, this.conf);\n  }\n};\n","export default {\n  methods: {\n    notify(type) {\n      this.___vemit(type, this.data);\n    },\n    listen(type, fn) {\n      this.___von(type, e => {\n        fn(e);\n      });\n    }\n  },\n  destroyed() {\n    this.___voff();\n  }\n};\n","<template>\n  <li class=\"v-node\" :key=\"data.level\">\n    <i\n      class=\"fa\"\n      :class=\"folderClass\"\n      @click=\"notify('unfold')\"\n    ></i>\n    <span @click=\"notify('change')\">\n      <i class=\"fa\" :class=\"checkboxClass\"></i>\n      {{data.name}}\n    </span>\n  </li>\n</template>\n\n<script>\n  import EventMixin from './mixin';\n\n  const classNames = [\n    'fa-square-o',\n    'fa-minus-square-o',\n    'fa-check-square-o',\n  ];\n\n  export default {\n    name: 'v-node',\n    mixins: [EventMixin],\n    props: {\n      data: {\n        type: Object,\n        required: true\n      },\n      uid: {\n        type: [String, Number],\n        required: true\n      }\n    },\n    computed: {\n      folderClass() {\n        let data = this.data;\n        let folderLoding = data.status === 'loading';\n        let folderOpen = data.canOpen && data.open;\n        let isEmpty = !data.canOpen && data.status === 'done';\n        return {\n          'fa-spinner cursor-progress': folderLoding,\n          'fa-folder-open-o': !folderLoding && folderOpen,\n          'fa-folder-o': !folderLoding && !folderOpen,\n          'cursor-no-ops': isEmpty\n        };\n      },\n      checkboxClass() {\n        return classNames[this.data.check + 1];\n      }\n    }\n  };\n</script>\n","<template>\n  <li class=\"v-leaf\" @click=\"notify('change')\" :key=\"data.level\">\n    <i class=\"fa\" :class=\"className\"></i>\n    {{data.name}}\n  </li>\n</template>\n\n<script>\n  import EventMixin from './mixin';\n\n  const classNames = [\n    'fa-square-o',\n    'fa-minus-square-o',\n    'fa-check-square-o',\n  ];\n\n  export default {\n    name: 'v-leaf',\n    mixins: [EventMixin],\n    props: {\n      data: {\n        type: Object,\n        required: true\n      },\n      uid: {\n        type: [String, Number],\n        required: true\n      }\n    },\n    computed: {\n      className() {\n        return classNames[this.data.check + 1];\n      }\n    }\n  };\n</script>\n","<template>\n  <li :key=\"node.level\" class=\"v-branch\">\n    <ul class=\"v-branch-body\">\n      <v-node :data=\"node\" :uid=\"uid\"></v-node>\n      <v-branch v-show=\"node.open\" v-for=\"branch in branches\" :data=\"branch\" :uid=\"uid\"></v-branch>\n      <v-leaf v-show=\"node.open\" v-for=\"leaf in leafs\" :data=\"leaf\" :uid=\"uid\"></v-leaf>\n    </ul>\n  </li>\n</template>\n\n<script>\n  import EventMixin from './mixin';\n  import VLeaf from './v-leaf.vue';\n  import VNode from './v-node.vue';\n\n  export default {\n    name: 'v-branch',\n    mixins: [EventMixin],\n    props: {\n      data: {\n        type: Object,\n        required: true\n      },\n      uid: {\n        type: [String, Number],\n        required: true\n      }\n    },\n    components: {\n      'v-node': VNode,\n      'v-leaf': VLeaf\n    },\n    computed: {\n      branches() {\n        return this.data.branches;\n      },\n      leafs() {\n        return this.data.leafs;\n      },\n      node() {\n        return  this.data.node;\n      }\n    }\n  };\n</script>\n","<template>\n  <ul class=\"v-branch-body\">\n    <v-node :data=\"node\" :uid=\"uid\"></v-node>\n    <v-branch v-show=\"node.open\" v-for=\"branch in branches\" :data=\"branch\" :uid=\"uid\"></v-branch>\n    <v-leaf v-show=\"node.open\" v-for=\"leaf in leafs\" :data=\"leaf\" :uid=\"uid\"></v-leaf>\n  </ul>\n</template>\n<script>\n  let KEY_MAP = {};\n  import Store from './store';\n  import EventMixin from './mixin';\n  import VNode from './v-node.vue';\n  import VLeaf from './v-leaf.vue';\n  import VBranch from './v-branch.vue';\n\n  export default {\n    name: 'v-folder',\n    mixins: [EventMixin],\n    props: {\n      data: Object,\n      uid: {\n        type: [String, Number],\n        required: true\n      },\n      ajax: Object,\n      conf: Object\n    },\n    components: {\n      'v-node': VNode,\n      'v-leaf': VLeaf,\n      'v-branch': VBranch\n    },\n    data() {\n      return {\n        store: new Store(this.data, this.conf)\n      };\n    },\n    computed: {\n      root() {\n        return this.store.dataStore;\n      },\n      branches() {\n        return this.root.branches;\n      },\n      leafs() {\n        return this.root.leafs;\n      },\n      node() {\n        return this.root.node;\n      }\n    },\n    methods: {\n      request(node, done) {\n        if (!this.ajax) {\n          return done('ajax:false');\n        }\n        \n        let conf = this.conf || {};\n        let dirKey  = conf['branch'] || 'dirs';\n        let fileKey = conf['leaf'] || 'files';\n        let nameKey = conf['node'] || 'name';\n  \n        let reqConf = this.ajax;\n        let { url, method, data, params, pathAs } = reqConf;\n        let isGET = method.toUpperCase() === 'GET';\n        \n        if (isGET) {\n          reqConf.params = (params || {});\n          reqConf.params[pathAs] = node.path;\n        } else {\n          reqConf.data = (data || {});\n          reqConf.data[pathAs] = node.path;\n        }\n\n        this.$http(reqConf).then(res => {\n          let data = res.data;\n          data[dirKey] = data[dirKey].map(d => ({[nameKey]: d}));\n          done(null, data);\n        })\n        .catch(e => {\n          done(e);\n        });\n      }\n    },\n    created() {\n      let uid = this.uid;\n      if (uid in KEY_MAP) {\n        throw 'each <v-folder> instance must get an unique `uid` property';\n      } else {\n        KEY_MAP[uid] = null;\n      }\n\n      this.listen('change', node => {\n        this.store.commit('change', node, (res) => this.$emit('change', res));\n      });\n\n      this.listen('unfold', node => {\n        this.store.commit('fold', node, () => {\n          node.status = 'loading';\n  \n          this.request(node, (err, data) => {\n            if (err) {\n              node.status = 'empty';\n            } else {\n              this.store.merge(data, node);\n            }\n          });\n        });\n      });\n    }\n  };\n</script>\n\n<style scoped>\n  /*----------------------------------------------------------------\n                            .v-branch\n  ---------------------------------------------------------------*/\n  .v-branch-body {\n    padding: 0;\n    font-size: 18px;\n    color: #666;\n    list-style: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n  }\n  .v-branch-body .v-branch {\n    position: relative;\n    padding-left: 27px;\n  }\n  /*.v-branch:before,\n  .v-branch:after,\n  .v-leaf:before,\n  .v-leaf:after {\n    content: '';\n    position: absolute;\n    left: 0;\n    width: 25px;\n    height: 50%;\n    border-left: 1px solid;\n    border-bottom: 1px solid;\n  }\n  .v-branch:after, \n  .v-leaf:after {\n    border-bottom: 0;\n    bottom: 0;\n  }*/\n  .v-branch ul {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n\n  /*----------------------------------------------------------------\n                            .v-node\n  ---------------------------------------------------------------*/\n  .v-node {\n    position: relative;\n    padding: 0 0 0  27px;\n    list-style: none;\n  }\n  .v-node .fa {\n    width: 20px;\n    color: #0d83e6;\n    text-align: center;\n    cursor: pointer;\n  }\n  .v-node .fa:hover {\n    color: #0c71c5;\n  }\n\n  .v-node > .fa {\n    position: absolute;\n    left: 0;\n    top: 1px;\n  }\n  .v-node > .span {\n    cursor: pointer;\n  }\n\n  /*----------------------------------------------------------------\n                            .v-leaf\n  ---------------------------------------------------------------*/\n  .v-leaf {\n    position: relative;\n    margin: 0;\n    padding: 0 0 0 27px;\n    cursor: pointer;\n  }\n  .v-leaf .fa {\n    display: inline-block;\n    width: 20px;\n    color: #0d83e6;\n    text-align: center;\n    font: normal normal normal 14px/1 FontAwesome;\n    font-size: inherit;\n    text-rendering: auto;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale\n  }\n  .v-leaf .fa:hover {\n    color: #0c71c5;\n  }\n\n  .cursor-no-ops {\n    cursor: not-allowed;\n  }\n  .cursor-progress {\n    cursor: progress;\n  }\n</style>\n\n\n","export const eventMix = function (Vue) {\n  let hub = new Vue();\n  let proto = Vue.prototype;\n\n  proto.___von = function (type, cb) {\n    let uid = this.uid;\n    let vm = this;\n    let fn = function(e) {\n      if (uid === e.uid && cb) {\n        cb(e.data);\n      }\n    };\n    hub.$on(`#${uid}@${type}`, fn);\n  };\n\n  proto.___vemit = function (type, data) {\n    let uid = this.uid;\n    hub.$emit(`#${uid}@${type}`, { data, uid });\n  };\n\n  proto.___voff = function (type, fn) {\n    let uid = this.uid;\n\n    if (type) {\n      hub.$off(`#${uid}@${type}`, fn);\n    } else {\n      uid = `#${uid}@`\n      let len = uid.length;\n      let types = Object.keys(hub._events);\n      let match = types.filter(k => k.indexOf(uid) === 0);\n      match.forEach(k => {\n        hub.$off(k, fn);\n      })\n    }\n  };\n};\n","import VFolderComp from './index.vue';\nimport { eventMix } from './install';\n\nVFolderComp.install = Vue => {\n  let [mj, mi, pa] = Vue.version.split('.');\n  \n  if (mj > 2 || mj === 2 && (mi > 1 || mi === 1 && pa >= 5)) {\n    throw 'You should at least get Vue.js@2.1.5.'\n  }\n\n  eventMix(Vue);\n  Vue.component(VFolderComp.name, VFolderComp);\n};\n\nexport default VFolderComp;\n"],"names":["toObject","val","undefined","TypeError","Object","shouldUseNative","assign","test1","String","getOwnPropertyNames","test2","i","fromCharCode","order2","map","n","join","test3","split","forEach","letter","keys","err","transform","data","config","level","path","node","branch","leaf","check","open","name","branches","leafs","canOpen","length","type","let","status","getOwnPropertySymbols","hasOwnProperty","prototype","propIsEnumerable","propertyIsEnumerable","target","source","from","symbols","to","s","arguments","key","call","clone","obj","temp","Array","value","arrPush","push","noop","_","defaultConf","Store","conf","filter","slice","this","objectAssign","dataStore","replace","newTree","findParentBranch","levelId","lvs","index","shift","findCurrentBranch","checkBranchAscendents","nextStatus","branchesAllChecked","some","b","leafsAllChecked","f","branchesAllUnchecked","leafsAllUnChecked","checkBranchDescendents","l","this$1","checkNode","checkState","nextState","checkLeaf","leafBranch","merge","deepClone","top","pos","pop","splice","commit","action","elem","callback","isNode","getPathResult","result","ref","apply","raw","methods","notify","___vemit","listen","fn","___von","e","destroyed","___voff","classNames","render","mixins","EventMixin","props","required","uid","Number","computed","folderClass","folderLoding","folderOpen","isEmpty","fa-spinner cursor-progress","fa-folder-open-o","fa-folder-o","cursor-no-ops","checkboxClass","className","components","v-node","VNode","v-leaf","VLeaf","KEY_MAP","ajax","v-branch","VBranch","store","root","request","done","dirKey","nameKey","reqConf","method","params","pathAs","isGET","toUpperCase","$http","then","res","d","catch","created","$emit","eventMix","Vue","hub","proto","cb","$on","$off","types","_events","match","k","indexOf","VFolderComp","install","version","mj","mi","pa","component"],"mappings":"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"}